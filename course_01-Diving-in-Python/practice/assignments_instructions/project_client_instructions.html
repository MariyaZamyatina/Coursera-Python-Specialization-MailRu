<meta charset="utf-8"/>
<co-content>
 <h2 level="2">
  Хранение метрик
 </h2>
 <p>
  Если вы разрабатываете настоящий проект, у которого есть большое количество пользователей, то необходимо наблюдать за всеми процессами, происходящими в нем. Для этого нужно смотреть за численными показателями в проекте. Показатели могут быть самыми разными - количество запросов к вашему приложению, время ответа вашего сервиса на каждый запрос, количество пользователей в сутки, и т.д. Эти всевозможные численные показатели мы будем называть метриками.
 </p>
 <p>
  Для сбора, хранения и отображения подобных метрик существуют готовые решения, например Graphite, InfluxDB. Мы в рамках курса разработаем свою систему для сбора метрик - сервер и клиент.
 </p>
 <p>
  На этой неделе мы начнем с разработки клиента для отправки подобных метрик на сервер, где они хранятся, и могут быть запрошены в любой момент времени. Затем в качестве финального задания на шестой неделе вам будет предложено реализовать и сам сервер.
 </p>
 <h2 level="2">
  Протокол взаимодействия
 </h2>
 <p>
  Итак, на этой неделе вам необходимо разработать сетевую программу-клиент, при помощи которой можно отправлять различные метрики на сервер. Клиент и сервер должны взаимодействовать между собой по простому текстовому протоколу через TCP сокеты. Текстовый протокол имеет главное преимущество – он наглядный – можно просмотреть диалог взаимодействия клиентской и серверной стороны без использования дополнительных инструментов.
 </p>
 <p>
  Прежде чем реализовывать клиентское приложение давайте рассмотрим взаимодействие между клиентом и сервером на конкретных примерах.
 </p>
 <p>
  Предположим, необходимо собирать метрики о работе операционной системы: cpu (загрузка процессора), memory usage (потребление памяти), disk usage (потребление места на жестком диске), network usage (статистика сетевых интерфейсов) и т.д. Это понадобится для контроля загрузки серверов и прогноза по расширению парка железа компании - проще говоря для мониторинга.
 </p>
 <p>
  Пусть у нас имеется в наличии два сервера palm и eardrum. Мы будем получать загрузку центрального процессора на сервере и отправлять метрику с названием имя_сервера.cpu
 </p>
 <pre language="plain_text">client -&gt; server: put palm.cpu 10.6 1501864247\n

server -&gt; client: ok\n\n

client -&gt; server: put eardrum.cpu 15.3 1501864259\n

server -&gt; client: ok\n\n</pre>
 <p>
  Чтобы отправить метрику на сервер, вы отправляете в TCP-соединение строку вида:
 </p>
 <p>
  <strong>
   put palm.cpu 10.6 1501864247\n
  </strong>
 </p>
 <p>
  Ключевое слово put означает команду отправки метрики. За ней через пробел следует название (имя) самой метрики, например palm.cpu, далее опять через пробел значение метрики, и через еще один пробел временная метка unix timestamp. Таким образом, во время  1501864247 значение метрики palm.cpu было равно 10.6. Наконец, команда заканчивается символом переноса строки \n.
 </p>
 <p>
  В ответ на эту команду put сервер присылает уведомление об успешном сохранении метрики в виде строки:
 </p>
 <p>
  <strong>
   ok\n\n
  </strong>
 </p>
 <p>
  Два переноса строки в данном случае означают маркер конца сообщения от сервера клиенту.
 </p>
 <h2 level="2">
  Команды
 </h2>
 <p>
  Необходимо реализовать две команды:
 </p>
 <p>
  <strong>
   put -
  </strong>
  для сохранения метрик на сервере.
 </p>
 <p>
  <strong>
   get -
  </strong>
  для получения метрик.
 </p>
 <p>
  Формат команды put для отправки метрик — это строка вида:
 </p>
 <p>
  <strong>
   put &lt;key&gt; &lt;value&gt; &lt;timestamp&gt;\n
  </strong>
 </p>
 <p>
  Успешный ответ от сервера:
 </p>
 <p>
  <strong>
   ok\n\n
  </strong>
 </p>
 <p>
  Ошибка сервера:
 </p>
 <p>
  <strong>
   error\nwrong command\n\n
  </strong>
 </p>
 <p>
  Обратите внимание на то, что за каждым ответом сервера указано два символа \n. В качестве значения метрики value используется вещественное число.
 </p>
 <p>
  Данные нужно не только отправлять на сервер, но и запрашивать их. Это может потребоваться для визуализации и анализа нужных метрик в определенные промежутки времени.
 </p>
 <p>
  Формат команды get для получения метрик — это строка вида:
 </p>
 <p>
  <strong>
   get &lt;key&gt;\n
  </strong>
 </p>
 <p>
  В качестве ключа можно указывать символ *, для этого символа будут возвращены все доступные метрики. В данном задании мы никак не ограничиваем количество метрик, которые должен вернуть сервер – сервер должен возвращать все метрики, удовлетворяющие ключу.
 </p>
 <p>
  Успешный ответ от сервера:
 </p>
 <p>
  <strong>
   ok\n
  </strong>
  <strong>
   palm.cpu 10.5 1501864247\n
  </strong>
  <strong>
   eardrum.cpu 15.3 1501864259\n\n
  </strong>
 </p>
 <p>
  Если ни одна метрика не удовлетворяет условиям поиска, то вернется ответ:
 </p>
 <p>
  <strong>
   ok\n\n
  </strong>
 </p>
 <p>
  Обратите внимание, что каждая успешная операция начинается с "ok", а за ответом сервера всегда указано два символа \n.
 </p>
 <h2 level="2">
  Реализация клиента.
 </h2>
 <p>
  Необходимо реализовать класс Client, в котором будет инкапсулировано соединение с сервером, клиентский сокет и методы для получения и отправки метрик на сервер. В конструктор класса Client должна передаваться адресная пара хост и порт, а также необязательный аргумент timeout (timeout=None по умолчанию). У класса Client должно быть 2 метода: put и get, соответствующих протоколу выше.
 </p>
 <p>
  Пример вызова клиента для отправки метрик и затем их получения:
 </p>
 <pre language="python">client = Client("127.0.0.1", 8888, timeout=15)

client.put("palm.cpu", 0.5, timestamp=1150864247)
client.put("palm.cpu", 2.0, timestamp=1150864248)
client.put("palm.cpu", 0.5, timestamp=1150864248)

client.put("eardrum.cpu", 3, timestamp=1150864250)
client.put("eardrum.cpu", 4, timestamp=1150864251)
client.put("eardrum.memory", 4200000)

print(client.get("*"))</pre>
 <p>
  Клиент получает данные в текстовом виде, метод get должен возвращать словарь с полученными ключами с сервера. Значением ключа в словаре является список кортежей [(timestamp, metric_value), ...], отсортированный по timestamp от меньшего к большему. Значение timestamp должно быть преобразовано к целому числу int. Значение метрики metric_value нужно преобразовать к числу с плавающей точкой float.
 </p>
 <p>
  Метод put принимает первым аргументом название метрики, вторым численное значение, третьим - необязательный именованный аргумент timestamp. Если пользователь вызвал метод put без аргумента timestamp, то клиент автоматически должен подставить текущее время в команду put - str(int(time.time()))
 </p>
 <p>
  Метод put не возвращает ничего в случае успешной отправки и выбрасывает исключение ClientError в случае неуспешной.
 </p>
 <p>
  Метод get принимает первым аргументом имя метрики, значения которой мы хотим выгрузить. Также вместо имени метрики можно использовать символ *, о котором говорилось в описании протокола.
 </p>
 <p>
  Метод get возвращает словарь с метриками (смотрите ниже пример) в случае успешного получения ответа от сервера и выбрасывает исключение ClientError в случае неуспешного.
 </p>
 <p>
  Пример возвращаемого значения при успешном вызове client.get("palm.cpu"):
 </p>
 <pre language="plain_text">{
  'palm.cpu': [
    (1150864247, 0.5),
    (1150864248, 0.5)
  ]
}</pre>
 <p>
  Пример возвращаемого значения при успешном вызове client.get("*"):
 </p>
 <pre language="plain_text">{
  'palm.cpu': [
    (1150864247, 0.5),
    (1150864248, 0.5)
  ],
  'eardrum.cpu': [
    (1150864250, 3.0),
    (1150864251, 4.0)
  ],
  'eardrum.memory': [
    (1503320872, 4200000.0)
  ]
}</pre>
 <p>
  Если в ответ на get-запрос сервер вернул положительный ответ ok\n\n, но без данных (то есть данных по запрашиваемому ключу нет), то метод get клиента должен вернуть пустой словарь:
 </p>
 <pre language="python">&gt;&gt;&gt; client.get("non_existing_key")
{}</pre>
 <p>
  Обратите внимание, что сервер хранит данные с максимальным разрешением в одну секунду. Это означает, что если в одну и ту же секунду отправить две одинаковые метрики, то будет сохранено только одно значение, которое было обработано последним. Все остальные значения будут перезаписаны.
 </p>
 <p>
  Итак, вам необходимо предоставить модуль с классом Client, исключением ClientError. В этом классе Client должны быть доступны методы get и put с описанной выше сигнатурой. При вызове методов get и put клиент должен посылать сообщения в TCP-соединение с сервером в соответствии с описанным текстовым протоколом, получать ответ от сервера, преобразовывать его в удобный для использования формат, описанный выше.
 </p>
 <p>
  Код клиента неудобно разрабатывать и отлаживать без сервера. Для удобства тестирования во время разработки кода клиента мы разработали unittest-ты.
 </p>
 <asset assettype="generic" extension="py" id="u4XTi6ssEeehSg7dYzt83A" name="test_week5">
 </asset>
 <p>
  Используйте данный unittest для проверки работы Вашего клиента для отправки метрик. Это ускорит процесс разработки клиента и упростит отладку. Проверяйте работу перед отправкой решения на оценку.
 </p>
 <p>
  Успехов при выполнении задания!
 </p>
</co-content>
<style>
 body {
    padding: 50px 85px 50px 85px;
}

table th, table td {
    border: 1px solid #e0e0e0;
    padding: 5px 20px;
    text-align: left;
}
input {
    margin: 10px;
}
}
th {
    font-weight: bold;
}
td, th {
    display: table-cell;
    vertical-align: inherit;
}
img {
    height: auto;
    max-width: 100%;
}
pre {
    display: block;
    margin: 20px;
    background: #424242;
    color: #fff;
    font-size: 13px;
    white-space: pre-wrap;
    padding: 9.5px;
    margin: 0 0 10px;
    border: 1px solid #ccc;
}
</style>
<script async="" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
</script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$$','$$'], ['$','$'] ],
      displayMath: [ ["\\[","\\]"] ],
      processEscapes: true
    }
  });
</script>
